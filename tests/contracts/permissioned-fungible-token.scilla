
(* @dev Implementation of Permissioned Fungible Token Contract *)

scilla_version 0
import BoolUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library PermissionedFungibleToken

(* Standard Enums *)
let zero = Uint128 0

let min_int =
  fun (a : Uint128) => fun (b : Uint128) =>
  let alt = builtin lt a b in
  match alt with
  | True =>
    a
  | False =>
    b
  end

(* Computes a <= b *)
let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
    end

(* Checks if the the transfer is allowed *)
(* Recipient must be in the whitelist *)
let check_transfer_allowed =
  fun (recipient_whitelist: Option String) =>
  fun (owner_address: ByStr20) =>
  fun (recipient: ByStr20) =>
    match recipient_whitelist with
    | Some inlist => True
    | None => 
      let recipient_is_contract_owner = builtin eq owner_address recipient in
      match recipient_is_contract_owner with
      | True => True
      | False => False
      end
    end

let check_allowance =
  fun (allowed_tokens : Option Uint128) =>
  fun (tokens : Uint128) =>
    match allowed_tokens with
    | Some v =>
      let sufficient_tokens = le_int tokens v in
      match sufficient_tokens with
      | True => True
      | False => False 
      end
    | None => False
    end

(* Get Recipient's new balance after transfer has succeeded *)
let get_recipient_new_balance =
  fun (current_balance: Option Uint128) =>
  fun (tokens : Uint128) =>
  match current_balance with
  | Some bal => builtin add tokens bal
  | None => tokens
  end

(* Generic error events wrapper *)
let make_error_event=
  fun (label: String) =>
  fun ( msg: String) =>
    { _eventname : "Error"; label : label ; message: msg }


(* Event for generic messages *)
let make_success_event =
  fun (label: String) =>
  fun ( msg: String) =>
    { _eventname : "Success"; label : label ; message: msg }

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract PermissionedFungibleToken
(token_issuer: ByStr20,
 total_tokens : Uint128,
 token_name: String,
 token_symbol: String)

(* Initial balance is not stated explicitly: it's initialized when creating the contract. *)

field token_balances : Map ByStr20 Uint128 =
  let m = Emp ByStr20 Uint128 in
    builtin put m token_issuer total_tokens
field token_allowances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(* Whitelist participants *)
field registry : Map ByStr20 String = Emp ByStr20 String


(* @param: Member address                                         *)
(* @param: Description of the member (e.g. serial number)         *)
transition AddMember(member_address: ByStr20, description: String)
  checkOwner = builtin eq _sender token_issuer;
  match checkOwner with
  | True =>
    registry[member_address] := description;
    e = let label = "AddMember" in
      let msg = "Success" in
      make_success_event label msg;
    event e
  | False =>
    e = let label = "AddMember" in
      let msg = "Unauthorized" in
      make_success_event label msg;
    event e
  end
end

transition BalanceOf (token_owner : ByStr20)
  bal <- token_balances[token_owner];
  match bal with
  | Some v =>
	e = {_eventname : "BalanceOf"; address : token_owner; balance : v};
	event e
  | None =>
	e = {_eventname : "BalanceOf"; address : token_owner; balance : Uint128 0};
    event e
  end
end

transition TotalSupply ()
  e = {_eventname : "TotalSupply"; caller : _sender; balance : total_tokens};
  event e
end

transition TransferFrom (from : ByStr20, to : ByStr20, tokens : Uint128)
  get_current_balance <- token_balances[from];

  (* Tokens can only be transferred to a recipient who is whitelisted or contract owner *)
  is_whitelisted <- registry[to];
  check_transfer = check_transfer_allowed is_whitelisted token_issuer to;
  match check_transfer with
  | True =>  
    (* Checks if `from` has sufficient tokens *)
    match get_current_balance with
    | Some balance =>
        sufficient_balance = le_int tokens balance;
        match sufficient_balance with
        | True =>
          (* Checks if _sender is an entity that is approved by the owner *)
          is_sender_owner = builtin eq _sender from;
          match is_sender_owner with
          | False =>
            (* _sender is not owner. Check if he has sufficient allowance *)
            get_allowance <- token_allowances[from][_sender];
            transfer_allowed  = check_allowance get_allowance tokens;
            match transfer_allowed with
            | True =>
              (* Deducts the tokens from allowance *)
              match get_allowance with
              | Some current_allowance =>
                new_allowance = builtin sub current_allowance tokens;
                token_allowances[from][_sender] := new_allowance
              | None => (* Should not happen due to "check_allowance" library *)
              end;

              (* Deduct balance from `from` *)
              new_balance = builtin sub balance tokens;
              token_balances[from] := new_balance;

              (* Update recipient balance *)
              recipient_current_balance <- token_balances[to];
              new_balance = get_recipient_new_balance recipient_current_balance tokens;
              token_balances[to] := new_balance;

              (* Emits success message *)
              e = {_eventname: "Success: TransferFrom (Approved)"; sender: _sender; from : from; to: to; tokens: tokens};
              event e


            | False =>
              e = let label = "TransferFrom" in
                let msg = "Insufficient allowance or not authorized" in
                make_error_event label msg;
              event e
            end
          | True =>
            (* Deduct balance from `from` *)
            new_balance = builtin sub balance tokens;
            token_balances[from] := new_balance;

            (* Update recipient balance *)
            recipient_current_balance <- token_balances[to];
            new_balance = get_recipient_new_balance recipient_current_balance tokens;
            token_balances[to] := new_balance;

            (* Emits success message *)
            e = {_eventname: "Success: TransferFrom (Owner)"; from : from; to: to; tokens: tokens};
            event e

          end

        | False =>
          e = let label = "TransferFrom" in
            let msg = "Insufficient Balance" in
            make_error_event label msg;
          event e
        end
    | None =>
        e = let label = "TransferFrom" in
          let msg = "Insufficient Balance" in
          make_error_event label msg;
        event e
    end

  | False =>
    e = let label = "TransferFrom" in
      let msg = "Failure: Transfer not allowed" in
      make_error_event label msg;
    event e
  end
end

transition Approve (spender : ByStr20, value: Uint128)
  (* Checks if the `spender` is whitelisted *)
  is_whitelisted <- registry[spender];
  check_transfer = check_transfer_allowed is_whitelisted token_issuer spender;
  match check_transfer with
  | True =>
    (* Use the value from the parameter even if the existing spender already has some allowance *)
    token_allowances[_sender][spender] := value;
    e = {_eventname : "Success: Approve"; approver : _sender; spender : spender; amount : value};
    event e
  | False =>
    e = let label = "Approve" in
      let msg = "Spender is not whitelisted" in
      make_error_event label msg;
    event e
  end
end

transition Allowance (token_owner : ByStr20, spender : ByStr20)
  spender_allowance <- token_allowances[token_owner][spender];
  match spender_allowance with
  | Some n =>
      e = {_eventname : "Allowance"; owner : token_owner; spender : spender; amount : n};
      event e
  | None =>
      e = {_eventname : "Allowance"; owner : token_owner; spender : spender; amount : Uint128 0};
      event e
  end
end
